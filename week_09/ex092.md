# ex_09_2 文件加密（Caesar Cipher）解題技巧

## 題目重點
- 需將英文字母依指定位數「前移」或「後移」做加密（凱薩加密）。
- 只處理英文字母（大小寫），非字母不變。
- 需能處理正負位移（前移用負數，後移用正數）。

## 解題步驟
1. **理解題意**  
   - 前移 N：字母往字母表前面數 N 格（如 a 前移 3 變成 x）。
   - 後移 N：字母往字母表後面數 N 格（如 a 後移 3 變成 d）。
   - 需考慮環狀（z 後移 1 變 a，a 前移 1 變 z）。

2. **設計函數**  
   - 寫一個 `shift_char(c, shift)` 處理單一字母的位移。
   - 用 `ord()` 及 `chr()` 轉換字母與 ASCII 編碼，計算新位置。
   - 用 `% 26` 處理超出 a~z 範圍的環狀。

3. **處理字串**  
   - 寫一個 `encrypt(text, shift)`，對每個字元呼叫 `shift_char`。
   - 用 `''.join()` 組合加密後的字串。

4. **測資與輸出**  
   - 依題目給定的四組測資，分別呼叫加密函數。
   - 印出原字串、移動位數、加密結果。

## 常見錯誤提醒
- 忘記大小寫分開處理。
- 沒有處理負數位移（前移）。
- 沒有用 `% 26` 做環狀處理。
- 非字母（如空白、標點）應保持不變。

## 範例程式片段
```python
def shift_char(c, shift):
    if 'a' <= c <= 'z':
        return chr((ord(c) - ord('a') + shift) % 26 + ord('a'))
    elif 'A' <= c <= 'Z':
        return chr((ord(c) - ord('A') + shift) % 26 + ord('A'))
    else:
        return c

def encrypt(text, shift):
    return ''.join(shift_char(c, shift) for c in text)
```

## 小技巧
- 前移 N 格等同後移 26-N 格，可用負數表示前移。
- 測資可用 list 儲存，for 迴圈批次處理。
- 印出時說明「前移」或「後移」與位數，方便對照。

---
chr
是 Python 的內建函式，用來將整數（Unicode 編碼）轉換成對應的字元。例如，   chr(65) 會回傳字母 'A'，因為 65 是大寫 A 的 Unicode 編碼。這個函式常用於字元編碼、加密解密（如凱薩加密）、或需要根據數值產生字母的情境。與之相對的是 ord，可以將字元轉成對應的整數編碼。

這段程式碼定義了一個名為    encrypt 的函式，用來對輸入的字串    text 進行加密。函式接受兩個參數：   text（要加密的原始字串）和    shift（位移的位數）。在函式內，''.join(shift_char(c, shift) for c in text) 會對    text 中的每個字元    c，呼叫前面定義的    shift_char 函式進行位移處理，然後把所有處理後的字元組合成一個新的字串並回傳。這種寫法常用於凱薩加密（Caesar cipher），可以讓整個字串的英文字母依指定位數進行加密。注意：開頭的 ef 應為 def，否則會造成語法錯誤。

這段程式碼定義了一個名為    shift_char 的函式，用來對單一字元    c 進行位移（通常用於凱薩加密 Caesar cipher）。函式接受兩個參數：   c 是要處理的字元，   shift 是位移的位數。 首先，判斷    c 是否為小寫英文字母（'a' <= c <= 'z'）。如果是，就將    c 轉成對應的 Unicode 編碼（   ord(c)），減去    ord('a') 得到 0<del>25 的索引，再加上位移值    shift，用 % 26 保證結果仍在 0</del>25 範圍，最後再加回    ord('a') 轉回字元。這樣可以讓字母在 a~z 之間循環位移。 如果    c 是大寫英文字母（'A' <= c <= 'Z'），則用同樣的方式處理，只是基準點換成    ord('A')。 如果    c 不是英文字母（例如數字、標點符號或空白），就直接原樣回傳，不做任何改變。這種設計可以讓加密或解密時只影響英文字母，其他字元保持不變。
