# 凱薩加密（Caesar Cipher）學習筆記

## 程式碼說明

### 加密原理解釋

這段程式碼用來說明字母加密（凱薩加密 Caesar cipher）的運作原理。

#### 範例：以 "cheer" 字串「前移 7」為例

```python
print("\n=== 加密原理解釋 ===")
for i, char in enumerate("cheer"):
    encrypted_char = shift_char(char, 7)
    # 詳細處理過程...
```

#### 處理步驟

1. `for i, char in enumerate("cheer"):` 會逐一處理 "cheer" 中的每個字母

2. 在每次迴圈中：
   - `shift_char(char, 7)` 將該字母往後（或往前，視正負號）移動 7 個字母
   - 得到加密後的新字母

3. 位置計算：
   - `char_pos = ord(char) - ord('a')` 計算原本字母在 a~z 中的位置（例如 c 是 2）
   - `new_pos = (char_pos + 7) % 26` 計算加密後的新位置

4. 輸出結果：
   ```python
   print(f"{char} (位置{char_pos}) + 7 = {encrypted_char} (位置{new_pos})")
   ```
   詳細列出每個字母的原始位置、加密後的字母及其新位置

### 字串累加操作

#### 程式碼說明
```python
encrypted += encrypted_char
```

這行程式碼的意思是將變數 `encrypted_char` 的內容加到 `encrypted` 這個字串的後面，並把結果再存回 `encrypted`。

#### 用途
- 常用於字串累加
- 在加密過程中，會把每一個加密後的字元依序接到結果字串 `encrypted` 上
- 最後得到完整的加密訊息

#### 運算子說明
- `+=` 是「加法賦值運算子」
- 用來簡化 `encrypted = encrypted + encrypted_char` 的寫法

## 核心概念

### 加密流程
1. **單字元加密**：把原始字串中的每個字元單獨加密
2. **字串拼接**：將加密後的字元依序拼接起來
3. **完整結果**：形成一個新的加密字串

### 重要特性
- 利用模運算（`% 26`）讓字母在 a~z 之間循環
- 每個字元經過加密（位移）後，用 `+=` 加到結果字串後面
- 最終得到完整的加密訊息

## 學習重點

這樣的說明有助於理解：
- 加密演算法如何根據字母位置進行位移
- 如何利用模運算讓字母循環
- 字串累加的實作方式

如果位移數是 28，效果等同於位移 2，因為英文字母有 26 個，位移會「循環」回到開頭。 以    new_char_num = (char_num + shift_amount) % 26 這行來看，
假設原本字母是 'a'（char_num = 0），位移 28：                        所以 'a' 會變成字母表第 2 個，也就是 'c'。 總結： • 位移 28，等同於位移 2（因為 28 % 26 = 2） • 超過 26 的位移會自動循環回字母表開頭 • 這是因為 % 26 會把位移數限制在 0~25 之間

%26：是否意謂，除26後的餘數     092s.md:66-75       GitHub Copilot     已使用 1 個參考   是的，% 26 就是「除以 26 之後的餘數」。
在 Python 中，% 是「取餘數」的運算子（稱為「模運算」）。
這樣做的目的是讓字母位移時，超過 26 個字母就會自動從頭開始循環。 例如： • 28 % 26 = 2，代表位移 28 格，其實等同於位移 2 格。 • 25 % 26 = 25，26 % 26 = 0，27 % 26 = 1  這就是為什麼凱薩加密裡用 % 26 可以讓字母在 a~z 之間循環不斷。

這行程式碼的作用是把一個代表字母位置的數字轉換回對應的小寫英文字母。   new_char_num 是 0 到 25 之間的整數，代表 a~z 的位置。   ord('a') 會得到字母 a 的 Unicode 編碼（通常是 97），所以    new_char_num + ord('a') 就是新字母的 Unicode 編碼。最後用    chr() 把這個編碼轉回字母，得到加密後的新字元。這種寫法常用於凱薩加密等字母位移演算法，讓數字和字母之間可以互相轉換。

enumerate  是 Python 的內建函式，用來在迴圈中同時取得元素的索引（編號）和值。當你用 for i, value in enumerate(串列): 這種寫法時，i 會自動從 0 開始編號，value 則是串列中的每個元素。這樣可以讓你在遍歷資料時，不需要自己額外設計計數器，就能同時取得索引和內容。   enumerate 也可以指定起始編號，例如    enumerate(串列, 1) 會讓索引從 1 開始。這個函式常用於需要同時處理元素和其位置的情境，讓程式碼更簡潔易讀。

這段程式碼用來逐一說明字串 "cheer" 中每個字母經過「前移 7 位」加密後的變化過程。for i, char in enumerate("cheer"): 會同時取得每個字母的索引（   i）和字母本身（   char），雖然這裡    i 沒有被用到，主要是為了方便擴充。 每次迴圈，encrypted_char = shift_char(char, 7) 會呼叫    shift_char 函式，把字母往後移動 7 位，得到加密後的新字母。char_pos = ord(char) - ord('a') 會計算原本字母在 a<del>z 中的位置（例如 c 是 2），new_pos = (char_pos + 7) % 26 則計算加密後的新位置，利用 % 26 保證結果在 0</del>25 之間循環。 最後，print(f"{char} (位置{char_pos}) + 7 = {encrypted_char} (位置{new_pos})") 會詳細列出每個字母的原始位置、加密後的字母及其新位置，讓你清楚看到每一步的轉換過程。這種寫法非常適合用來教學或說明凱薩加密（Caesar cipher）的原理。

這行程式碼使用了條件運算式（又稱三元運算子），根據變數 shift 的值來決定方向。如果 shift 大於 0，則 direction 會被設為 "前移"（代表字母往後移動，例如凱薩加密的加密方向）；否則，設為 "後移"（代表字母往前移動，通常用於解密）。這種寫法可以根據位移值自動決定描述用語，讓程式輸出更直觀易懂。
