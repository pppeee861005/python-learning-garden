# Week 09 作業一解題筆記

## 題目概述

### 第一題：刪除串列中所有負數
- **題目**：已知串列 `x = [1, 3, 5, 0, -1, 3, -2]`，請撰寫程式刪除list中所有負數，並印出結果串列。
- **目標**：移除串列中的負數元素

### 第二題：計算二維串列中負數的總個數
- **題目**：已知串列 `y = [[1, -1, 0], [2, 5, -9], [-2, -3, 0]]`，請撰寫程式計算並印出list中負數的總個數。
- **目標**：統計二維串列中負數的數量

## 解題思路

### 第一題解法分析

#### 方法一：串列推導式 (List Comprehension)
```python
x_filtered = [num for num in x if num >= 0]
```
- **優點**：程式碼簡潔，執行效率高
- **缺點**：對初學者可能較難理解
- **適用場景**：熟悉Python語法的開發者

#### 方法二：filter() 函數
```python
x_filtered = list(filter(lambda num: num >= 0, x))
```
- **優點**：函數式程式設計風格
- **缺點**：需要理解lambda函數
- **適用場景**：函數式程式設計愛好者

#### 方法三：迴圈建立新串列 ⭐（採用方法）
```python
x_filtered = []
for num in x:
    if num >= 0:
        x_filtered.append(num)
```
- **優點**：邏輯清晰，容易理解，適合初學者
- **缺點**：程式碼較長
- **適用場景**：初學者學習，邏輯清晰的場合

#### 方法四：直接修改原串列
```python
for i in range(len(x) - 1, -1, -1):
    if x[i] < 0:
        x.pop(i)
```
- **優點**：節省記憶體空間
- **缺點**：會破壞原始資料，需要從後往前遍歷
- **適用場景**：記憶體限制嚴格的情況

### 第二題解法分析

#### 方法一：巢狀迴圈 ⭐（採用方法）
```python
negative_count = 0
for row in y:
    for num in row:
        if num < 0:
            negative_count += 1
```
- **優點**：邏輯直觀，容易理解和除錯
- **缺點**：程式碼較長
- **適用場景**：初學者學習，需要清晰邏輯的場合

#### 方法二：串列推導式配合 sum()
```python
negative_count = sum(1 for row in y for num in row if num < 0)
```
- **優點**：程式碼簡潔，執行效率高
- **缺點**：語法較複雜
- **適用場景**：熟悉Python進階語法的開發者

#### 方法三：先展平串列再計算
```python
flattened = [num for row in y for num in row]
negative_count = sum(1 for num in flattened if num < 0)
```
- **優點**：分步驟處理，邏輯清晰
- **缺點**：需要額外記憶體存儲展平後的串列
- **適用場景**：需要重複使用展平串列的情況

## 關鍵概念

### 1. 串列操作
- **建立新串列**：不修改原始資料，安全性高
- **修改原串列**：節省記憶體，但可能影響原始資料

### 2. 條件判斷
- **負數判斷**：`num < 0`
- **非負數判斷**：`num >= 0`（包含0）

### 3. 迴圈技巧
- **正向遍歷**：`for i in range(len(list))`
- **反向遍歷**：`for i in range(len(list) - 1, -1, -1)`
- **巢狀迴圈**：處理二維資料結構

### 4. 計數技巧
- **累加計數**：`count += 1`
- **條件計數**：結合if判斷進行計數

## 執行結果

### 第一題結果
- **原始串列**：`[1, 3, 5, 0, -1, 3, -2]`
- **處理後串列**：`[1, 3, 5, 0, 3]`
- **移除的負數**：`-1, -2`

### 第二題結果
- **原始二維串列**：`[[1, -1, 0], [2, 5, -9], [-2, -3, 0]]`
- **負數總個數**：`4`
- **負數位置**：
  - `y[0][1] = -1`
  - `y[1][2] = -9`
  - `y[2][0] = -2`
  - `y[2][1] = -3`

## 學習重點

1. **選擇適合的方法**：根據程式設計經驗和需求選擇最適合的解法
2. **理解資料結構**：一維串列 vs 二維串列的處理差異
3. **迴圈設計**：單層迴圈 vs 巢狀迴圈的應用時機
4. **條件判斷**：正確設定篩選條件
5. **程式碼可讀性**：平衡簡潔性和可讀性

## 延伸思考

1. 如果要處理三維串列，該如何修改程式？
2. 如何同時統計正數、負數、零的個數？
3. 如何找出負數的最大值和最小值？
4. 如何將所有負數轉換為正數？

## 程式設計原則

1. **可讀性優先**：程式碼要容易理解和維護
2. **功能正確性**：確保程式邏輯正確
3. **效率考量**：在滿足需求的前提下考慮執行效率
4. **錯誤處理**：考慮邊界情況和異常處理


for row in y:
    for num in row:
        if num < 0:
            negative_count += 1
            print(f"找到負數 {num},目前負數總個數: {negative_count}")
這段程式碼用來統計並顯示二維串列    y 中所有負數的數量。外層的    for row in y: 會逐列讀取    y 裡的每一個子串列（每一列）。內層的    for num in row: 則會依序檢查該列中的每個數字。如果發現    num < 0（也就是這個數字是負數），就會把    negative_count 這個計數器加一，並印出目前找到的負數及累計的負數總個數。這種寫法可以即時追蹤和顯示二維資料中負數的分布情況，常用於資料分析或錯誤檢查。注意：   negative_count 需在這段程式碼之前正確初始化（如設為 0），否則會出現錯誤。
